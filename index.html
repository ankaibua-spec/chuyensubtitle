showCodecError(analysis) {
                const placeholder = document.getElementById('videoPlaceholder');
                placeholder.innerHTML = `
                    <div style="color: #dc2626; text-align: center;">
                        <div style="font-size: 2em; margin-bottom: 15px;">‚ùå</div>
                        <div style="font-size: 1.2em; font-weight: 600; margin-bottom: 10px;">
                            Format kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£
                        </div>
                        <div style="font-size: 14px; color: #7f1d1d; margin-bottom: 20px;">
                            ${analysis.fileType} kh√¥ng th·ªÉ play tr√™n browser n√†y
                        </div>
                        <button onclick="location.reload()" style="padding: 10px 20px; background: #dc2626; color: white; border: none; border-radius: 8px; cursor: pointer;">
                            üîÑ Ch·ªçn video kh√°c
                        </button>
                    </div>
                `;
            }

            showCodecWarning(analysis) {
                const warningHTML = `
                    <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                            <span style="font-size: 1.5em;">‚ö†Ô∏è</span>
                            <div style="font-weight: 600; color: #92400e;">Codec Warning</div>
                        </div>
                        <div style="color: #92400e; margin-bottom: 15px;">
                            <strong>Detected:</strong> ${analysis.likelyCodec}<br>
                            <strong>Issue:</strong> ${analysis.conversionReason}
                        </div>
                        <div style="color: #78350f; font-size: 14px; margin-bottom: 15px;">
                            Video c√≥ th·ªÉ kh√¥ng load ƒë∆∞·ª£c. N·∫øu g·∫∑p l·ªói, h√£y convert sang H.264.
                        </div>
                        ${this.getConversionLinksHTML()}
                    </div>
                `;
                
                // Insert warning after instruction panel
                const instructionPanel = document.querySelector('.instruction-panel');
                const warningDiv = document.createElement('div');
                warningDiv.innerHTML = warningHTML;
                instructionPanel.parentNode.insertBefore(warningDiv, instructionPanel.nextSibling);
            }

            showConversionRequired(analysis) {
                const placeholder = document.getElementById('videoPlaceholder');
                placeholder.innerHTML = `
                    <div style="color: #dc2626; text-align: center; padding: 20px;">
                        <div style="font-size: 2em; margin-bottom: 15px;">üîÑ</div>
                        <div style="font-size: 1.2em; font-weight: 600; margin-bottom: 10px;">
                            Conversion Required
                        </div>
                        <div style="font-size: 14px; color: #7f1d1d; margin-bottom: 15px;">
                            Video codec <strong>${analysis.likelyCodec}</strong> kh√¥ng ƒë∆∞·ª£c browser h·ªó tr·ª£
                        </div>
                        <div style="background: #fef2f2; border-radius: 8px; padding: 15px; margin: 15px 0;">
                            <div style="font-weight: 600; margin-bottom: 10px;">üõ†Ô∏è Convert sang format t∆∞∆°ng th√≠ch:</div>
                            ${this.getConversionLinksHTML(true)}
                        </div>
                        <button onclick="location.reload()" style="padding: 10px 20px; background: #6b7280; color: white; border: none; border-radius: 8px; cursor: pointer; margin-top: 10px;">
                            üîÑ Th·ª≠ video kh√°c
                        </button>
                    </div>
                `;
            }

            getConversionLinksHTML(compact = false) {
                const links = [
                    { name: 'CloudConvert', url: 'https://cloudconvert.com/mp4-converter', desc: 'Free, 25 files/day' },
                    { name: 'Media.io', url: 'https://www.media.io/video-converter.html', desc: 'AI-powered' },
                    { name: 'Zamzar', url: 'https://www.zamzar.com/convert/mp4/', desc: 'Reliable' }
                ];
                
                if (compact) {
                    return links.map(link => 
                        `<a href="${link.url}" target="_blank" style="display: inline-block; background: #22c55e; color: white; padding: 8px 12px; border-radius: 6px; text-decoration: none; margin: 2px; font-size: 12px; font-weight: 600;">${link.name}</a>`
                    ).join(' ');
                } else {
                    return `
                        <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                            ${links.map(link => 
                                `<a href="${link.url}" target="_blank" style="display: block; background: #22c55e; color: white; padding: 10px 15px; border-radius: 8px; text-decoration: none; font-weight: 600; text-align: center; min-width: 120px; transition: all 0.3s;">
                                    <div>${link.name}</div>
                                    <div style="font-size: 11px; opacity: 0.9; margin-top: 2px;">${link.desc}</div>
                                </a>`
                            ).join('')}
                        </div>
                        <div style="margin-top: 15px; padding: 10px; background: #e0f2fe; border-radius: 8px; font-size: 12px; color: #0c4a6e;">
                            <strong>Recommended:</strong> MP4 + H.264 (AVC) + AAC audio
                        </div>
                    `;
                }
            }            testVideoQuick(file) {
                return new Promise((resolve, reject) => {
                    const video = document.createElement('video');
                    video.preload = 'metadata';
                    
                    const timeout = setTimeout(() => {
                        console.log('Quick video test timeout');
                        resolve(false);
                    }, 3000);
                    
                    video.addEventListener('loadedmetadata', () => {
                        clearTimeout(timeout);
                        console.log('Quick video test SUCCESS:', video.videoWidth + 'x' + video.videoHeight);
                        resolve(true);
                    }, { once: true });
                    
                    video.addEventListener('error', (e) => {
                        clearTimeout(timeout);
                        console.log('Quick video test FAILED:', e.target.error);
                        resolve(false);
                    }, { once: true });
                    
                    try {
                        const url = URL.createObjectURL(file);
                        video.src = url;
                    } catch (error) {
                        clearTimeout(timeout);
                        resolve(false);
                    }
                });
            }            fileToDataURL(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    reader.onprogress = (e) => {
                        if (e.lengthComputable) {
                            const percentComplete = (e.loaded / e.total) * 100;
                            this.updateLoadingText(`ƒêang ƒë·ªçc file: ${percentComplete.toFixed(0)}%`);
                            console.log('FileReader progress:', percentComplete.toFixed(1) + '%');
                        }
                    };
                    
                    reader.onload = () => {
                        console.log('FileReader completed');
                        resolve(reader.result);
                    };
                    
                    reader.onerror = (e) => {
                        console.error('FileReader error:', e);
                        reject(new Error('Kh√¥ng th·ªÉ ƒë·ªçc file'));
                    };
                    
                    reader.readAsDataURL(file);
                });
            }            checkVideoSupport(file) {
                const video = document.createElement('video');
                const basicSupport = video.canPlayType(file.type);
                
                // Test specific codec combinations
                const codecTests = {
                    'H.264 Baseline': video.canPlayType('video/mp4; codecs="avc1.42E01E"'),
                    'H.264 Main': video.canPlayType('video/mp4; codecs="avc1.4D4015"'),
                    'H.264 High': video.canPlayType('video/mp4; codecs="avc1.640028"'),
                    'H.265 HEVC': video.canPlayType('video/mp4; codecs="hev1.1.6.L93.B0"'),
                    'WebM VP8': video.canPlayType('video/webm; codecs="vp8"'),
                    'WebM VP9': video.canPlayType('video/webm; codecs="vp9"')
                };
                
                // Detect likely codec from file characteristics
                let likelyCodec = 'H.264';
                let needsConversion = false;
                let conversionReason = '';
                
                if (file.type === 'video/mp4') {
                    // iPhone/Android files are usually HEVC if small size + high quality
                    if ((file.size < 20 * 1024 * 1024) && (file.name.includes('IMG_') || file.name.includes('VID_') || file.name.includes('MOV_'))) {
                        likelyCodec = 'H.265 (HEVC)';
                        if (codecTests['H.265 HEVC'] !== 'probably') {
                            needsConversion = true;
                            conversionReason = 'HEVC codec kh√¥ng ƒë∆∞·ª£c browser h·ªó tr·ª£ ƒë·∫ßy ƒë·ªß';
                        }
                    }
                }
                
                const analysis = {
                    fileName: file.name,
                    fileType: file.type,
                    fileSize: file.size,
                    basicSupport: basicSupport,
                    likelyCodec: likelyCodec,
                    codecTests: codecTests,
                    needsConversion: needsConversion,
                    conversionReason: conversionReason,
                    supported: basicSupport !== ''
                };
                
                console.log('Video analysis:', analysis);
                return analysis;
            }<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCR Subtitle t·ª´ Video</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 24px;
            box-shadow: 0 24px 80px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            animation: fadeIn 0.6s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 3em;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-content {
            padding: 40px;
        }

        .upload-area {
            border: 3px dashed #e0e6ed;
            border-radius: 16px;
            padding: 60px;
            text-align: center;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 30px;
        }

        .upload-area:hover {
            border-color: #667eea;
            background: linear-gradient(135deg, #f0f4ff 0%, #e6f1ff 100%);
        }

        .upload-area.dragover {
            border-color: #667eea;
            background: linear-gradient(135deg, #e6f1ff 0%, #dae8ff 100%);
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 4em;
            margin-bottom: 20px;
            color: #667eea;
        }

        .upload-text {
            font-size: 1.4em;
            color: #334155;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .upload-subtext {
            color: #64748b;
            font-size: 1.1em;
        }

        .content-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 40px;
            margin-top: 30px;
        }

        .video-panel {
            background: #f8fafc;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
        }

        .text-panel {
            background: #f8fafc;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
        }

        .panel-title {
            font-size: 1.4em;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .video-container {
            position: relative;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        #videoPlayer {
            width: 100%;
            display: block;
        }

        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .video-overlay.active {
            pointer-events: all;
            cursor: crosshair;
        }

        .selection-rectangle {
            position: absolute;
            border: 3px solid #ff4444;
            background: rgba(255, 68, 68, 0.1);
            pointer-events: none;
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.8);
        }

        .selection-handles {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ff4444;
            border: 2px solid white;
            border-radius: 50%;
            cursor: nw-resize;
        }

        .handle-tl { top: -6px; left: -6px; }
        .handle-tr { top: -6px; right: -6px; cursor: ne-resize; }
        .handle-bl { bottom: -6px; left: -6px; cursor: sw-resize; }
        .handle-br { bottom: -6px; right: -6px; cursor: se-resize; }

        .video-placeholder {
            height: 400px;
            background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #64748b;
            font-size: 1.2em;
            text-align: center;
            border: 2px dashed #cbd5e1;
        }

        .controls-section {
            margin-top: 25px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }

        .control-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            flex: 1;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
        }

        .btn-warning:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(107, 114, 128, 0.3);
        }

        .language-selector select {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 14px;
            background: white;
            color: #334155;
            transition: border-color 0.3s ease;
        }

        .language-selector select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .input-group {
            display: flex;
            gap: 10px;
        }

        .input-group input {
            flex: 1;
            padding: 10px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        #textOutput {
            width: 100%;
            min-height: 400px;
            padding: 20px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 15px;
            line-height: 1.7;
            resize: vertical;
            font-family: 'Monaco', 'SF Mono', monospace;
            background: white;
            transition: border-color 0.3s ease;
        }

        #textOutput:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .progress-container {
            margin-top: 20px;
            display: none;
        }

        .progress-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
            color: #64748b;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #10b981);
            border-radius: 10px;
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .export-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 25px;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 16px 24px;
            border-radius: 12px;
            color: white;
            font-weight: 600;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            z-index: 1000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
            max-width: 350px;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success { background: linear-gradient(135deg, #10b981, #059669); }
        .notification.error { background: linear-gradient(135deg, #ef4444, #dc2626); }
        .notification.info { background: linear-gradient(135deg, #3b82f6, #2563eb); }

        .selection-info {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        .selection-info.active {
            display: block;
        }

        .selection-coords {
            font-family: 'Monaco', 'SF Mono', monospace;
            font-size: 12px;
            color: #0369a1;
            margin-top: 5px;
        }

        .frame-preview {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: #f8fafc;
            border-radius: 8px;
        }

        .frame-item {
            position: relative;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .frame-item:hover {
            border-color: #667eea;
            transform: scale(1.02);
        }

        .frame-item.processing {
            border-color: #f59e0b;
        }

        .frame-item.completed {
            border-color: #10b981;
        }

        .frame-item img {
            width: 100%;
            height: 80px;
            object-fit: cover;
        }

        .frame-time {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.8);
            color: white;
            font-size: 10px;
            padding: 2px 4px;
            text-align: center;
        }

        .api-config {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .api-config h3 {
            color: #92400e;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        @media (max-width: 1200px) {
            .content-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .control-row {
                flex-direction: column;
            }
            
            .export-options {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2.2em;
            }
            
            .main-content {
                padding: 20px;
            }
            
            .upload-area {
                padding: 40px 20px;
            }
        }

        .hidden { display: none !important; }

        .instruction-panel {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 1px solid #0ea5e9;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .instruction-panel h3 {
            color: #0369a1;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .instruction-steps {
            list-style: none;
            padding: 0;
        }

        .instruction-steps li {
            padding: 8px 0;
            color: #0c4a6e;
            position: relative;
            padding-left: 30px;
        }

        .instruction-steps li::before {
            content: counter(step-counter);
            counter-increment: step-counter;
            position: absolute;
            left: 0;
            top: 8px;
            background: #0ea5e9;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }

        .instruction-steps {
            counter-reset: step-counter;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé¨ OCR Subtitle t·ª´ Video</h1>
            <p>Tr√≠ch xu·∫•t ch·ªØ t·ª´ subtitle c√≥ s·∫µn trong video b·∫±ng AI Vision</p>
        </div>

        <div class="main-content">
            <div class="instruction-panel">
                <h3>üìã H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng</h3>
                <ol class="instruction-steps">
                    <li>Upload video c√≥ subtitle ƒë∆∞·ª£c in s·∫µn (hard-coded)</li>
                    <li>V·∫Ω khung ch·ªØ nh·∫≠t bao quanh v√πng subtitle tr√™n video</li>
                    <li>C·∫•u h√¨nh OpenAI API key (ho·∫∑c d√πng Tesseract offline)</li>
                    <li>Ch·ªçn kho·∫£ng th·ªùi gian v√† t·∫ßn su·∫•t extract frames</li>
                    <li>Nh·∫•n "Tr√≠ch xu·∫•t OCR" ƒë·ªÉ b·∫Øt ƒë·∫ßu x·ª≠ l√Ω</li>
                </ol>
                
                <div style="margin-top: 15px; padding: 15px; background: #fef2f2; border: 1px solid #fca5a5; border-radius: 8px;">
                    <div style="font-weight: 600; color: #dc2626; margin-bottom: 10px;">üîß N·∫øu video kh√¥ng hi·ªÉn th·ªã:</div>
                    <div style="font-size: 14px; color: #7f1d1d;">
                        ‚Ä¢ Th·ª≠ convert video sang <strong>MP4 (H.264 codec)</strong><br>
                        ‚Ä¢ Check Console (F12) xem error c·ª• th·ªÉ<br>
                        ‚Ä¢ File size &lt; 500MB, resolution &lt; 4K<br>
                        ‚Ä¢ D√πng Chrome/Edge cho compatibility t·ªët nh·∫•t
                    </div>
                    <button onclick="window.videoExtractor.testFormats()" style="margin-top: 10px; padding: 8px 16px; background: #dc2626; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                        üß™ Test Video Support
                    </button>
                </div>
            </div>

            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">üìÅ</div>
                <div class="upload-text">K√©o th·∫£ video v√†o ƒë√¢y ho·∫∑c nh·∫•n ƒë·ªÉ ch·ªçn</div>
                <div class="upload-subtext">H·ªó tr·ª£ MP4, MOV, AVI, WebM v·ªõi subtitle in s·∫µn</div>
                <input type="file" id="videoInput" accept="video/*" style="display: none;">
            </div>

            <div class="content-grid">
                <div class="video-panel">
                    <div class="panel-title">
                        üé• Video & Ch·ªçn v√πng Subtitle
                    </div>
                    
                    <div class="video-placeholder" id="videoPlaceholder">
                        <div>
                            <div style="font-size: 2em; margin-bottom: 10px;">üìπ</div>
                            <div>Ch·ªçn video ƒë·ªÉ b·∫Øt ƒë·∫ßu</div>
                        </div>
                    </div>

                    <!-- Loading state -->
                    <div class="video-placeholder" id="videoLoading" style="display: none;">
                        <div>
                            <div style="font-size: 2em; margin-bottom: 10px; animation: pulse 2s infinite;">‚è≥</div>
                            <div>ƒêang t·∫£i video...</div>
                            <div style="margin-top: 15px;">
                                <button onclick="window.videoExtractor.cancelVideoLoad()" style="padding: 8px 16px; background: #dc2626; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                                    ‚ùå H·ªßy
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="video-container" id="videoContainer" style="display: none;">
                        <video id="videoPlayer" controls preload="metadata"></video>
                        <div class="video-overlay" id="videoOverlay"></div>
                        <div style="position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 5px; font-size: 12px; display: none;" id="videoInfo">
                            K√≠ch th∆∞·ªõc: <span id="videoDimensions"></span>
                        </div>
                    </div>

                    <div class="selection-info" id="selectionInfo">
                        <div style="font-weight: 600; color: #0369a1;">‚úÖ ƒê√£ ch·ªçn v√πng subtitle</div>
                        <div class="selection-coords" id="selectionCoords"></div>
                    </div>

                    <div class="controls-section">
                        <div class="control-group">
                            <div class="control-row">
                                <button id="selectAreaBtn" class="btn btn-primary" disabled>
                                    üéØ Ch·ªçn v√πng subtitle
                                </button>
                                <button id="clearSelectionBtn" class="btn btn-secondary" disabled>
                                    üóëÔ∏è X√≥a v√πng ch·ªçn
                                </button>
                            </div>
                        </div>

                        <div class="control-group">
                            <label>‚è±Ô∏è C·∫•u h√¨nh tr√≠ch xu·∫•t:</label>
                            <div class="input-group">
                                <input type="number" id="startTime" placeholder="B·∫Øt ƒë·∫ßu (s)" min="0" value="0">
                                <input type="number" id="endTime" placeholder="K·∫øt th√∫c (s)" min="0">
                                <input type="number" id="frameInterval" placeholder="M·ªói (s)" min="0.5" step="0.5" value="1">
                            </div>
                        </div>

                        <div class="control-group">
                            <label>üåç Ng√¥n ng·ªØ OCR:</label>
                            <div class="language-selector">
                                <select id="ocrLanguage">
                                    <option value="vie">üáªüá≥ Ti·∫øng Vi·ªát</option>
                                    <option value="eng">üá∫üá∏ English</option>
                                    <option value="chi_sim">üá®üá≥ ‰∏≠ÊñáÁÆÄ‰Ωì</option>
                                    <option value="chi_tra">üáπüáº ‰∏≠ÊñáÁπÅÈ´î</option>
                                    <option value="jpn">üáØüáµ Êó•Êú¨Ë™û</option>
                                    <option value="kor">üá∞üá∑ ÌïúÍµ≠Ïñ¥</option>
                                    <option value="fra">üá´üá∑ Fran√ßais</option>
                                    <option value="deu">üá©üá™ Deutsch</option>
                                    <option value="spa">üá™üá∏ Espa√±ol</option>
                                </select>
                            </div>
                        </div>

                        <div class="control-row">
                            <button id="extractFramesBtn" class="btn btn-warning" disabled>
                                üñºÔ∏è Tr√≠ch frames
                            </button>
                            <button id="startOcrBtn" class="btn btn-success" disabled>
                                üîç OCR Subtitle
                            </button>
                        </div>
                    </div>

                    <div class="progress-container" id="progressContainer">
                        <div class="progress-label">
                            <span id="progressText">ƒêang x·ª≠ l√Ω...</span>
                            <span id="progressPercent">0%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                    </div>

                    <div class="frame-preview" id="framePreview"></div>
                </div>

                <div class="text-panel">
                    <div class="api-config">
                        <h3>üîë C·∫•u h√¨nh API</h3>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">OpenAI API Key (t√πy ch·ªçn):</label>
                            <input type="password" id="apiKey" placeholder="sk-..." style="width: 100%; padding: 10px; border: 2px solid #e2e8f0; border-radius: 8px;">
                            <div style="font-size: 12px; color: #6b7280; margin-top: 5px;">
                                ƒê·ªÉ tr·ªëng ƒë·ªÉ d√πng Tesseract.js offline (ch·∫≠m h∆°n nh∆∞ng mi·ªÖn ph√≠)
                            </div>
                        </div>
                    </div>

                    <div class="panel-title">
                        üìÑ K·∫øt qu·∫£ OCR
                        <button id="clearTextBtn" class="btn btn-secondary" style="margin-left: auto; padding: 8px 16px; font-size: 14px;">
                            üóëÔ∏è X√≥a
                        </button>
                    </div>
                    
                    <textarea id="textOutput" placeholder="K·∫øt qu·∫£ OCR s·∫Ω xu·∫•t hi·ªán t·∫°i ƒë√¢y sau khi x·ª≠ l√Ω frames..."></textarea>

                    <div class="export-options">
                        <button id="downloadTxtBtn" class="btn btn-primary" disabled>
                            üíæ T·∫£i xu·ªëng .TXT
                        </button>
                        <button id="downloadSrtBtn" class="btn btn-success" disabled>
                            üé¨ T·∫£i xu·ªëng .SRT
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tesseract.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>

    <script>
        class VideoOCRExtractor {
            constructor() {
                this.videoFile = null;
                this.videoElement = null;
                this.canvas = null;
                this.ctx = null;
                this.isSelecting = false;
                this.isLoading = false;
                this.selectionBox = null;
                this.extractedFrames = [];
                this.ocrResults = [];
                this.tesseractWorker = null;
                
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.initCanvas();
                this.checkDependencies();
            }

            checkDependencies() {
                if (typeof Tesseract === 'undefined') {
                    this.showNotification('‚ö†Ô∏è Tesseract.js ch∆∞a ƒë∆∞·ª£c t·∫£i. M·ªôt s·ªë t√≠nh nƒÉng c√≥ th·ªÉ kh√¥ng ho·∫°t ƒë·ªông.', 'error');
                }
            }

            setupEventListeners() {
                const uploadArea = document.getElementById('uploadArea');
                const videoInput = document.getElementById('videoInput');
                const selectAreaBtn = document.getElementById('selectAreaBtn');
                const clearSelectionBtn = document.getElementById('clearSelectionBtn');
                const extractFramesBtn = document.getElementById('extractFramesBtn');
                const startOcrBtn = document.getElementById('startOcrBtn');
                const clearTextBtn = document.getElementById('clearTextBtn');
                const downloadTxtBtn = document.getElementById('downloadTxtBtn');
                const downloadSrtBtn = document.getElementById('downloadSrtBtn');
                const videoOverlay = document.getElementById('videoOverlay');

                // File upload
                uploadArea.addEventListener('click', () => videoInput.click());
                uploadArea.addEventListener('dragover', this.handleDragOver.bind(this));
                uploadArea.addEventListener('drop', this.handleFileDrop.bind(this));
                uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
                
                videoInput.addEventListener('change', this.handleFileSelect.bind(this));

                // Selection controls
                selectAreaBtn.addEventListener('click', this.toggleSelection.bind(this));
                clearSelectionBtn.addEventListener('click', this.clearSelection.bind(this));
                
                // Overlay events for selection
                videoOverlay.addEventListener('mousedown', this.startSelection.bind(this));
                videoOverlay.addEventListener('mousemove', this.updateSelection.bind(this));
                videoOverlay.addEventListener('mouseup', this.endSelection.bind(this));

                // Processing controls
                extractFramesBtn.addEventListener('click', this.extractFrames.bind(this));
                startOcrBtn.addEventListener('click', this.startOCR.bind(this));
                
                // Text controls
                clearTextBtn.addEventListener('click', this.clearText.bind(this));
                downloadTxtBtn.addEventListener('click', () => this.downloadFile('txt'));
                downloadSrtBtn.addEventListener('click', () => this.downloadFile('srt'));

                // Video events
                const videoPlayer = document.getElementById('videoPlayer');
                videoPlayer.addEventListener('loadedmetadata', this.onVideoLoaded.bind(this));
                videoPlayer.addEventListener('error', (e) => {
                    const error = e.target.error;
                    let errorMessage = 'L·ªói video kh√¥ng x√°c ƒë·ªãnh';
                    
                    if (error) {
                        switch(error.code) {
                            case error.MEDIA_ERR_ABORTED:
                                errorMessage = 'Video b·ªã h·ªßy b·ªüi ng∆∞·ªùi d√πng';
                                break;
                            case error.MEDIA_ERR_NETWORK:
                                errorMessage = 'L·ªói m·∫°ng khi t·∫£i video';
                                break;
                            case error.MEDIA_ERR_DECODE:
                                errorMessage = 'L·ªói decode video - codec kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£';
                                break;
                            case error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                                errorMessage = 'Format video kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£';
                                break;
                        }
                        console.error('Video error details:', error.code, error.message, errorMessage);
                    }
                    
                    this.showNotification(`‚ùå ${errorMessage}`, 'error');
                });
                videoPlayer.addEventListener('canplay', () => {
                    console.log('Video can play');
                });
                videoPlayer.addEventListener('loadstart', () => {
                    console.log('Video load started');
                });
            }

            initCanvas() {
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
            }

            handleDragOver(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.add('dragover');
            }

            handleFileDrop(e) {
                e.preventDefault();
                const uploadArea = document.getElementById('uploadArea');
                uploadArea.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                console.log('Dropped files:', files);
                
                if (files.length === 0) {
                    this.showNotification('Kh√¥ng c√≥ file n√†o ƒë∆∞·ª£c th·∫£ v√†o.', 'error');
                    return;
                }
                
                const file = files[0];
                
                if (!file.type.startsWith('video/')) {
                    this.showNotification(`File kh√¥ng h·ª£p l·ªá. ƒê·ªãnh d·∫°ng: ${file.type}. Vui l√≤ng ch·ªçn file video.`, 'error');
                    return;
                }
                
                console.log('Loading dropped video:', file.name, file.type);
                this.loadVideo(file);
            }

            handleFileSelect(e) {
                const file = e.target.files[0];
                console.log('Selected file:', file);
                
                if (!file) {
                    this.showNotification('Kh√¥ng c√≥ file n√†o ƒë∆∞·ª£c ch·ªçn.', 'error');
                    return;
                }
                
                if (!file.type.startsWith('video/')) {
                    this.showNotification(`File kh√¥ng h·ª£p l·ªá. ƒê·ªãnh d·∫°ng: ${file.type}. Vui l√≤ng ch·ªçn file video.`, 'error');
                    return;
                }
                
                // Check file size (optional, but good UX)
                const maxSize = 500 * 1024 * 1024; // 500MB
                if (file.size > maxSize) {
                    this.showNotification('File qu√° l·ªõn. Vui l√≤ng ch·ªçn video nh·ªè h∆°n 500MB.', 'error');
                    return;
                }
                
                console.log('Loading video file:', file.name, file.type, (file.size/1024/1024).toFixed(2) + 'MB');
                this.loadVideo(file);
            }

            cancelVideoLoad() {
                console.log('Cancelling video load...');
                this.isLoading = false;
                
                // Reset UI
                document.getElementById('videoLoading').style.display = 'none';
                document.getElementById('videoContainer').style.display = 'none';
                document.getElementById('videoPlaceholder').style.display = 'block';
                
                // Clean up video element
                if (this.videoElement && this.videoElement.src) {
                    try {
                        URL.revokeObjectURL(this.videoElement.src);
                    } catch(e) {
                        console.log('Error revoking URL:', e);
                    }
                    this.videoElement.src = '';
                }
                
                this.showNotification('‚ùå ƒê√£ h·ªßy t·∫£i video', 'info');
            }

            async loadVideo(file) {
                console.log('Starting video load process...');
                this.isLoading = true;
                
                // Analyze video codec and compatibility
                const analysis = this.checkVideoSupport(file);
                
                if (!analysis.supported) {
                    this.showCodecError(analysis);
                    this.isLoading = false;
                    return;
                }
                
                // Show codec warning if needed
                if (analysis.needsConversion) {
                    this.showCodecWarning(analysis);
                }
                
                this.videoFile = file;
                this.videoElement = document.getElementById('videoPlayer');
                const videoPlaceholder = document.getElementById('videoPlaceholder');
                const videoLoading = document.getElementById('videoLoading');
                const videoContainer = document.getElementById('videoContainer');
                
                // Clean up previous video if any
                if (this.videoElement.src) {
                    try {
                        URL.revokeObjectURL(this.videoElement.src);
                    } catch(e) {
                        console.log('Error revoking previous URL:', e);
                    }
                }
                
                // Quick compatibility test first
                console.log('Running quick video test...');
                const quickTestPassed = await this.testVideoQuick(file);
                
                if (!quickTestPassed && analysis.needsConversion) {
                    console.log('Quick test failed + conversion needed');
                    this.showConversionRequired(analysis);
                    this.isLoading = false;
                    return;
                }
                
                // Try loading the video
                this.tryLoadVideo(file, videoPlaceholder, videoLoading, videoContainer, analysis);
            }

            async tryLoadVideo(file, videoPlaceholder, videoLoading, videoContainer, analysis = null) {
                if (!this.isLoading) return;
                
                // Show loading state
                videoPlaceholder.style.display = 'none';
                videoLoading.style.display = 'block';
                videoContainer.style.display = 'none';

                // Method 1: Try createObjectURL (most common) with timeout
                try {
                    console.log('Trying Method 1: createObjectURL');
                    const url = URL.createObjectURL(file);
                    console.log('Created object URL:', url);
                    
                    const success = await this.loadVideoWithTimeout(url, 8000, () => {
                        if (!this.isLoading) return;
                        console.log('Method 1 success');
                        videoLoading.style.display = 'none';
                        videoContainer.style.display = 'block';
                        this.isLoading = false;
                        this.onVideoLoaded();
                    });
                    
                    if (!this.isLoading) return;
                    
                    if (!success) {
                        console.log('Method 1 timeout, trying Method 2');
                        URL.revokeObjectURL(url);
                        this.tryFileReader(file, videoPlaceholder, videoLoading, videoContainer, analysis);
                    }
                } catch (error) {
                    if (!this.isLoading) return;
                    console.log('Method 1 failed:', error.message);
                    this.tryFileReader(file, videoPlaceholder, videoLoading, videoContainer, analysis);
                }
            }

            async tryFileReader(file, videoPlaceholder, videoLoading, videoContainer, analysis = null) {
                if (!this.isLoading) return;
                
                try {
                    console.log('Trying Method 2: FileReader to Data URL');
                    
                    // Check file size - FileReader c√≥ th·ªÉ ch·∫≠m v·ªõi file l·ªõn
                    const maxSizeForDataURL = 30 * 1024 * 1024; // Reduce to 30MB for faster loading
                    if (file.size > maxSizeForDataURL) {
                        throw new Error('File qu√° l·ªõn cho Data URL method (>30MB)');
                    }

                    // Show progress for file reading
                    this.updateLoadingText('ƒêang ƒë·ªçc file...');
                    const dataURL = await this.fileToDataURL(file);
                    
                    if (!this.isLoading) return;
                    
                    console.log('Created data URL, length:', dataURL.length);
                    
                    this.updateLoadingText('ƒêang load video...');
                    const success = await this.loadVideoWithTimeout(dataURL, 10000, () => {
                        if (!this.isLoading) return;
                        console.log('Method 2 success');
                        videoLoading.style.display = 'none';
                        videoContainer.style.display = 'block';
                        this.isLoading = false;
                        this.onVideoLoaded();
                    });
                    
                    if (!this.isLoading) return;
                    
                    if (!success) {
                        throw new Error('Method 2 timeout');
                    }
                } catch (error) {
                    if (!this.isLoading) return;
                    console.log('Method 2 failed:', error.message);
                    this.isLoading = false;
                    this.showLoadError(error, file, videoPlaceholder, videoLoading, videoContainer, analysis);
                }
            }

            updateLoadingText(text) {
                const loadingDiv = document.getElementById('videoLoading');
                if (loadingDiv) {
                    const textElement = loadingDiv.querySelector('div:last-child');
                    if (textElement) {
                        textElement.textContent = text;
                    }
                }
            }

            loadVideoWithTimeout(url, timeoutMs, onSuccess) {
                return new Promise((resolve, reject) => {
                    const tempVideo = document.createElement('video');
                    let timeoutId;
                    let resolved = false;
                    
                    const cleanup = () => {
                        if (timeoutId) clearTimeout(timeoutId);
                        tempVideo.removeEventListener('loadedmetadata', successHandler);
                        tempVideo.removeEventListener('error', errorHandler);
                        tempVideo.removeEventListener('loadstart', loadStartHandler);
                        tempVideo.removeEventListener('progress', progressHandler);
                    };

                    const successHandler = () => {
                        if (resolved) return;
                        resolved = true;
                        cleanup();
                        console.log('Video metadata loaded successfully');
                        // Copy to actual video element
                        this.videoElement.src = url;
                        this.videoElement.addEventListener('loadedmetadata', onSuccess, { once: true });
                        resolve(true);
                    };

                    const errorHandler = (e) => {
                        if (resolved) return;
                        resolved = true;
                        cleanup();
                        const error = e.target.error;
                        console.log('Video load error:', error);
                        resolve(false);
                    };

                    const loadStartHandler = () => {
                        console.log('Video load started...');
                    };

                    const progressHandler = () => {
                        console.log('Video loading progress...');
                    };

                    // Set timeout
                    timeoutId = setTimeout(() => {
                        if (resolved) return;
                        resolved = true;
                        console.log('Video load timeout after', timeoutMs + 'ms');
                        cleanup();
                        resolve(false);
                    }, timeoutMs);

                    tempVideo.addEventListener('loadedmetadata', successHandler, { once: true });
                    tempVideo.addEventListener('error', errorHandler, { once: true });
                    tempVideo.addEventListener('loadstart', loadStartHandler, { once: true });
                    tempVideo.addEventListener('progress', progressHandler);
                    
                    // Set source and start loading
                    console.log('Setting video source and starting load...');
                    tempVideo.preload = 'metadata';
                    tempVideo.src = url;
                });
            }

            showLoadError(error, file, videoPlaceholder, videoLoading, videoContainer, analysis = null) {
                let errorMessage = 'Kh√¥ng th·ªÉ t·∫£i video';
                let isCodecIssue = false;
                
                if (error) {
                    switch(error.code) {
                        case 1: // MEDIA_ERR_ABORTED
                            errorMessage = 'T·∫£i video b·ªã h·ªßy';
                            break;
                        case 2: // MEDIA_ERR_NETWORK
                            errorMessage = 'L·ªói m·∫°ng ho·∫∑c file b·ªã l·ªói';
                            break;
                        case 3: // MEDIA_ERR_DECODE
                            errorMessage = 'Kh√¥ng th·ªÉ decode video - codec kh√¥ng h·ªó tr·ª£';
                            isCodecIssue = true;
                            break;
                        case 4: // MEDIA_ERR_SRC_NOT_SUPPORTED
                            errorMessage = 'Codec kh√¥ng ƒë∆∞·ª£c browser h·ªó tr·ª£';
                            isCodecIssue = true;
                            break;
                        default:
                            if (error.message && error.message.includes('safety check')) {
                                errorMessage = 'Browser block video v√¨ security policy';
                            }
                            break;
                    }
                }
                
                console.error('Final video load error:', {
                    error: error,
                    fileName: file.name,
                    fileType: file.type,
                    fileSize: (file.size/1024/1024).toFixed(2) + 'MB',
                    isCodecIssue: isCodecIssue
                });
                
                // Show error in placeholder
                videoLoading.style.display = 'none';
                videoContainer.style.display = 'none';
                videoPlaceholder.style.display = 'block';
                
                if (isCodecIssue && analysis) {
                    // Show codec-specific error with conversion options
                    videoPlaceholder.innerHTML = `
                        <div style="color: #dc2626; text-align: center; padding: 20px;">
                            <div style="font-size: 2em; margin-bottom: 15px;">üö´</div>
                            <div style="font-size: 1.3em; font-weight: 600; margin-bottom: 10px;">
                                Codec Not Supported
                            </div>
                            <div style="font-size: 14px; color: #7f1d1d; margin-bottom: 10px;">
                                ${errorMessage}
                            </div>
                            <div style="background: #fef2f2; border-radius: 8px; padding: 15px; margin: 15px 0; text-align: left;">
                                <div style="font-weight: 600; margin-bottom: 10px; color: #991b1b;">üìä Video Analysis:</div>
                                <div style="font-size: 13px; color: #7f1d1d;">
                                    ‚Ä¢ <strong>Detected Codec:</strong> ${analysis.likelyCodec}<br>
                                    ‚Ä¢ <strong>File Size:</strong> ${(file.size/1024/1024).toFixed(2)} MB<br>
                                    ‚Ä¢ <strong>Browser Support:</strong> ${analysis.basicSupport || 'None'}<br>
                                    ‚Ä¢ <strong>Issue:</strong> ${analysis.conversionReason || 'Codec incompatible'}
                                </div>
                            </div>
                            <div style="background: #e0f2fe; border-radius: 8px; padding: 15px; margin: 15px 0;">
                                <div style="font-weight: 600; margin-bottom: 10px; color: #0c4a6e;">üõ†Ô∏è Quick Fix Solutions:</div>
                                ${this.getConversionLinksHTML(true)}
                                <div style="margin-top: 10px; font-size: 12px; color: #0369a1;">
                                    Convert to: <strong>MP4 + H.264 + AAC</strong> for best compatibility
                                </div>
                            </div>
                            <div style="display: flex; gap: 10px; justify-content: center; margin-top: 15px;">
                                <button onclick="location.reload()" style="padding: 10px 20px; background: #6b7280; color: white; border: none; border-radius: 8px; cursor: pointer;">
                                    üîÑ Try Another Video
                                </button>
                                <button onclick="window.videoExtractor.showCodecHelp()" style="padding: 10px 20px; background: #2563eb; color: white; border: none; border-radius: 8px; cursor: pointer;">
                                    ‚ùì More Help
                                </button>
                            </div>
                        </div>
                    `;
                } else {
                    // Show generic error
                    videoPlaceholder.innerHTML = `
                        <div style="color: #dc2626; text-align: center; padding: 20px;">
                            <div style="font-size: 2em; margin-bottom: 15px;">‚ùå</div>
                            <div style="font-size: 1.2em; font-weight: 600; margin-bottom: 10px;">
                                ${errorMessage}
                            </div>
                            <div style="font-size: 14px; color: #7f1d1d; margin-bottom: 20px;">
                                File: ${file.name} (${(file.size/1024/1024).toFixed(2)} MB)
                            </div>
                            <div style="display: flex; gap: 10px; justify-content: center;">
                                <button onclick="location.reload()" style="padding: 10px 20px; background: #dc2626; color: white; border: none; border-radius: 8px; cursor: pointer;">
                                    üîÑ Try Another Video
                                </button>
                            </div>
                        </div>
                    `;
                }
                
                this.showNotification(`‚ùå ${errorMessage}`, 'error');
            }

            showCodecHelp() {
                const helpContent = `
                    <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; display: flex; align-items: center; justify-content: center;" onclick="this.remove()">
                        <div style="background: white; border-radius: 12px; padding: 30px; max-width: 600px; max-height: 80vh; overflow-y: auto; margin: 20px;" onclick="event.stopPropagation()">
                            <h2 style="margin-bottom: 20px; color: #1e293b;">üîß Video Codec Help</h2>
                            
                            <div style="margin-bottom: 20px;">
                                <h3 style="color: #374151; margin-bottom: 10px;">Why This Happens:</h3>
                                <p style="color: #6b7280; line-height: 1.6;">
                                    Modern phones (iPhone/Android) use <strong>HEVC (H.265)</strong> codec to save storage space. 
                                    However, many browsers don't fully support HEVC playback, causing the "codec not supported" error.
                                </p>
                            </div>
                            
                            <div style="margin-bottom: 20px;">
                                <h3 style="color: #374151; margin-bottom: 10px;">Solutions:</h3>
                                <div style="background: #f8fafc; padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                                    <strong>üì± Mobile Solution:</strong> Try using <strong>Safari on iPhone</strong> instead of Chrome. Safari has better HEVC support.
                                </div>
                                <div style="background: #f0f9ff; padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                                    <strong>üîÑ Conversion Solution:</strong> Convert video to H.264 format using online tools like CloudConvert or Media.io
                                </div>
                                <div style="background: #f0fdf4; padding: 15px; border-radius: 8px;">
                                    <strong>üñ•Ô∏è Desktop Solution:</strong> Use Chrome/Edge on desktop, or try Firefox which has better codec support
                                </div>
                            </div>
                            
                            <div style="text-align: center; margin-top: 20px;">
                                <button onclick="this.closest('[style*=\"position: fixed\"]').remove()" style="padding: 10px 20px; background: #2563eb; color: white; border: none; border-radius: 8px; cursor: pointer;">
                                    Got It! ‚úÖ
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.insertAdjacentHTML('beforeend', helpContent);
            }

            onVideoLoaded() {
                console.log('Video metadata loaded');
                console.log('Video dimensions:', this.videoElement.videoWidth, 'x', this.videoElement.videoHeight);
                console.log('Video duration:', this.videoElement.duration);
                
                // Update end time input
                const endTimeInput = document.getElementById('endTime');
                if (this.videoElement.duration) {
                    endTimeInput.value = Math.floor(this.videoElement.duration);
                    endTimeInput.max = Math.floor(this.videoElement.duration);
                }
                
                // Show video info
                const videoInfo = document.getElementById('videoInfo');
                const videoDimensions = document.getElementById('videoDimensions');
                if (videoInfo && videoDimensions) {
                    videoDimensions.textContent = `${this.videoElement.videoWidth} √ó ${this.videoElement.videoHeight}`;
                    videoInfo.style.display = 'block';
                }
                
                // Enable selection button
                document.getElementById('selectAreaBtn').disabled = false;
                
                this.showNotification(`‚úÖ Video ƒë√£ s·∫µn s√†ng! K√≠ch th∆∞·ªõc: ${this.videoElement.videoWidth}√ó${this.videoElement.videoHeight}`, 'success');
            }

            toggleSelection() {
                const overlay = document.getElementById('videoOverlay');
                const btn = document.getElementById('selectAreaBtn');
                
                if (overlay.classList.contains('active')) {
                    this.stopSelection();
                } else {
                    this.startSelectionMode();
                }
            }

            startSelectionMode() {
                const overlay = document.getElementById('videoOverlay');
                const btn = document.getElementById('selectAreaBtn');
                
                overlay.classList.add('active');
                btn.textContent = '‚ùå H·ªßy ch·ªçn v√πng';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
                
                this.showNotification('üéØ Click v√† k√©o ƒë·ªÉ ch·ªçn v√πng subtitle', 'info');
            }

            stopSelection() {
                const overlay = document.getElementById('videoOverlay');
                const btn = document.getElementById('selectAreaBtn');
                
                overlay.classList.remove('active');
                btn.textContent = 'üéØ Ch·ªçn v√πng subtitle';
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-primary');
                
                this.isSelecting = false;
            }

            startSelection(e) {
                if (!document.getElementById('videoOverlay').classList.contains('active')) return;
                
                this.isSelecting = true;
                const rect = this.videoElement.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                this.selectionStart = { x, y };
                
                // Remove existing selection
                this.clearSelectionBox();
                
                // Create new selection box
                this.selectionBox = document.createElement('div');
                this.selectionBox.className = 'selection-rectangle';
                this.selectionBox.style.left = x + 'px';
                this.selectionBox.style.top = y + 'px';
                this.selectionBox.style.width = '0px';
                this.selectionBox.style.height = '0px';
                
                document.getElementById('videoOverlay').appendChild(this.selectionBox);
            }

            updateSelection(e) {
                if (!this.isSelecting || !this.selectionBox) return;
                
                const rect = this.videoElement.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                
                const width = Math.abs(currentX - this.selectionStart.x);
                const height = Math.abs(currentY - this.selectionStart.y);
                const left = Math.min(this.selectionStart.x, currentX);
                const top = Math.min(this.selectionStart.y, currentY);
                
                this.selectionBox.style.left = left + 'px';
                this.selectionBox.style.top = top + 'px';
                this.selectionBox.style.width = width + 'px';
                this.selectionBox.style.height = height + 'px';
            }

            endSelection(e) {
                if (!this.isSelecting) return;
                
                this.isSelecting = false;
                
                // Get final selection coordinates
                const rect = this.videoElement.getBoundingClientRect();
                const videoWidth = this.videoElement.videoWidth;
                const videoHeight = this.videoElement.videoHeight;
                const displayWidth = rect.width;
                const displayHeight = rect.height;
                
                if (this.selectionBox) {
                    const boxRect = this.selectionBox.getBoundingClientRect();
                    const overlayRect = document.getElementById('videoOverlay').getBoundingClientRect();
                    
                    // Convert display coordinates to video coordinates
                    const scaleX = videoWidth / displayWidth;
                    const scaleY = videoHeight / displayHeight;
                    
                    this.selection = {
                        x: Math.round((boxRect.left - overlayRect.left) * scaleX),
                        y: Math.round((boxRect.top - overlayRect.top) * scaleY),
                        width: Math.round(boxRect.width * scaleX),
                        height: Math.round(boxRect.height * scaleY)
                    };
                    
                    this.showSelectionInfo();
                    this.stopSelection();
                    
                    // Enable frame extraction
                    document.getElementById('extractFramesBtn').disabled = false;
                    document.getElementById('clearSelectionBtn').disabled = false;
                }
            }

            showSelectionInfo() {
                const info = document.getElementById('selectionInfo');
                const coords = document.getElementById('selectionCoords');
                
                info.classList.add('active');
                coords.textContent = `V√πng ch·ªçn: ${this.selection.x}, ${this.selection.y}, ${this.selection.width}x${this.selection.height}`;
                
                this.showNotification('‚úÖ ƒê√£ ch·ªçn v√πng subtitle th√†nh c√¥ng!', 'success');
            }

            clearSelection() {
                this.clearSelectionBox();
                this.selection = null;
                
                document.getElementById('selectionInfo').classList.remove('active');
                document.getElementById('extractFramesBtn').disabled = true;
                document.getElementById('clearSelectionBtn').disabled = true;
                document.getElementById('startOcrBtn').disabled = true;
                
                // Clear frames and preview
                this.extractedFrames = [];
                document.getElementById('framePreview').innerHTML = '';
                
                this.showNotification('üóëÔ∏è ƒê√£ x√≥a v√πng ch·ªçn', 'info');
            }

            clearSelectionBox() {
                if (this.selectionBox) {
                    this.selectionBox.remove();
                    this.selectionBox = null;
                }
            }

            async extractFrames() {
                if (!this.videoFile || !this.selection) return;
                
                const startTime = parseFloat(document.getElementById('startTime').value) || 0;
                const endTime = parseFloat(document.getElementById('endTime').value) || this.videoElement.duration;
                const interval = parseFloat(document.getElementById('frameInterval').value) || 1;
                
                this.showProgress();
                this.extractedFrames = [];
                document.getElementById('framePreview').innerHTML = '';
                
                const totalFrames = Math.ceil((endTime - startTime) / interval);
                let processedFrames = 0;
                
                this.updateProgress(0, 'B·∫Øt ƒë·∫ßu tr√≠ch xu·∫•t frames...');
                
                for (let time = startTime; time <= endTime; time += interval) {
                    try {
                        const frameData = await this.captureFrame(time);
                        const frameInfo = {
                            time: time,
                            data: frameData,
                            processed: false
                        };
                        
                        this.extractedFrames.push(frameInfo);
                        this.addFrameToPreview(frameInfo, this.extractedFrames.length - 1);
                        
                        processedFrames++;
                        const progress = (processedFrames / totalFrames) * 100;
                        this.updateProgress(progress, `ƒê√£ tr√≠ch xu·∫•t ${processedFrames}/${totalFrames} frames`);
                        
                        // Small delay to prevent blocking UI
                        await new Promise(resolve => setTimeout(resolve, 50));
                        
                    } catch (error) {
                        console.error('Error extracting frame at', time, ':', error);
                    }
                }
                
                this.hideProgress();
                document.getElementById('startOcrBtn').disabled = false;
                this.showNotification(`‚úÖ ƒê√£ tr√≠ch xu·∫•t ${this.extractedFrames.length} frames`, 'success');
            }

            async captureFrame(time) {
                return new Promise((resolve, reject) => {
                    const video = this.videoElement;
                    
                    const onSeeked = () => {
                        try {
                            // Set canvas size to selection area
                            this.canvas.width = this.selection.width;
                            this.canvas.height = this.selection.height;
                            
                            // Draw the selected area from video to canvas
                            this.ctx.drawImage(
                                video,
                                this.selection.x, this.selection.y, this.selection.width, this.selection.height,
                                0, 0, this.selection.width, this.selection.height
                            );
                            
                            // Convert to data URL
                            const dataURL = this.canvas.toDataURL('image/png');
                            
                            video.removeEventListener('seeked', onSeeked);
                            resolve(dataURL);
                        } catch (error) {
                            video.removeEventListener('seeked', onSeeked);
                            reject(error);
                        }
                    };
                    
                    video.addEventListener('seeked', onSeeked);
                    video.currentTime = time;
                });
            }

            addFrameToPreview(frameInfo, index) {
                const preview = document.getElementById('framePreview');
                const frameDiv = document.createElement('div');
                frameDiv.className = 'frame-item';
                frameDiv.dataset.index = index;
                
                frameDiv.innerHTML = `
                    <img src="${frameInfo.data}" alt="Frame ${frameInfo.time}s">
                    <div class="frame-time">${frameInfo.time.toFixed(1)}s</div>
                `;
                
                frameDiv.addEventListener('click', () => {
                    this.videoElement.currentTime = frameInfo.time;
                });
                
                preview.appendChild(frameDiv);
            }

            async startOCR() {
                if (this.extractedFrames.length === 0) {
                    this.showNotification('Vui l√≤ng tr√≠ch xu·∫•t frames tr∆∞·ªõc.', 'error');
                    return;
                }
                
                const apiKey = document.getElementById('apiKey').value.trim();
                const useOpenAI = apiKey.length > 0;
                
                this.showProgress();
                this.ocrResults = [];
                document.getElementById('textOutput').value = '';
                
                const totalFrames = this.extractedFrames.length;
                let processedFrames = 0;
                
                this.updateProgress(0, useOpenAI ? 'ƒêang OCR v·ªõi OpenAI Vision...' : 'ƒêang OCR v·ªõi Tesseract.js...');
                
                for (let i = 0; i < this.extractedFrames.length; i++) {
                    const frame = this.extractedFrames[i];
                    const frameElement = document.querySelector(`[data-index="${i}"]`);
                    
                    if (frameElement) {
                        frameElement.classList.add('processing');
                    }
                    
                    try {
                        let text = '';
                        
                        if (useOpenAI) {
                            text = await this.ocrWithOpenAI(frame.data, apiKey);
                        } else {
                            text = await this.ocrWithTesseract(frame.data);
                        }
                        
                        if (text.trim()) {
                            const result = {
                                time: frame.time,
                                text: text.trim()
                            };
                            this.ocrResults.push(result);
                            
                            // Update text output in real-time
                            this.updateTextOutput();
                        }
                        
                        if (frameElement) {
                            frameElement.classList.remove('processing');
                            frameElement.classList.add('completed');
                        }
                        
                    } catch (error) {
                        console.error('OCR error for frame', i, ':', error);
                        
                        if (frameElement) {
                            frameElement.classList.remove('processing');
                        }
                    }
                    
                    processedFrames++;
                    const progress = (processedFrames / totalFrames) * 100;
                    this.updateProgress(progress, `ƒê√£ x·ª≠ l√Ω ${processedFrames}/${totalFrames} frames`);
                }
                
                this.hideProgress();
                this.updateDownloadButtons();
                
                if (this.ocrResults.length > 0) {
                    this.showNotification(`‚úÖ OCR ho√†n th√†nh! T√¨m th·∫•y text trong ${this.ocrResults.length} frames`, 'success');
                } else {
                    this.showNotification('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y text n√†o trong c√°c frames', 'info');
                }
            }

            async ocrWithOpenAI(imageData, apiKey) {
                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            model: 'gpt-4o',
                            messages: [
                                {
                                    role: 'user',
                                    content: [
                                        {
                                            type: 'text',
                                            text: 'Extract all text from this image. If there is subtitle text, return only the subtitle text. If no text is found, return empty string. Do not include any additional formatting or explanations.'
                                        },
                                        {
                                            type: 'image_url',
                                            image_url: {
                                                url: imageData
                                            }
                                        }
                                    ]
                                }
                            ],
                            max_tokens: 300
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`OpenAI API error: ${response.status}`);
                    }

                    const data = await response.json();
                    return data.choices[0]?.message?.content || '';
                    
                } catch (error) {
                    console.error('OpenAI OCR error:', error);
                    throw error;
                }
            }

            async ocrWithTesseract(imageData) {
                try {
                    if (!this.tesseractWorker) {
                        this.tesseractWorker = await Tesseract.createWorker();
                        const language = document.getElementById('ocrLanguage').value;
                        await this.tesseractWorker.loadLanguage(language);
                        await this.tesseractWorker.initialize(language);
                    }

                    const { data: { text } } = await this.tesseractWorker.recognize(imageData);
                    return text;
                    
                } catch (error) {
                    console.error('Tesseract OCR error:', error);
                    throw error;
                }
            }

            updateTextOutput() {
                const textOutput = document.getElementById('textOutput');
                let fullText = '';
                
                this.ocrResults
                    .sort((a, b) => a.time - b.time)
                    .forEach(result => {
                        fullText += `[${this.formatTime(result.time)}] ${result.text}\n`;
                    });
                
                textOutput.value = fullText;
                textOutput.scrollTop = textOutput.scrollHeight;
            }

            clearText() {
                document.getElementById('textOutput').value = '';
                this.ocrResults = [];
                this.updateDownloadButtons();
                this.showNotification('ƒê√£ x√≥a n·ªôi dung.', 'info');
            }

            updateDownloadButtons() {
                const hasText = document.getElementById('textOutput').value.trim().length > 0;
                document.getElementById('downloadTxtBtn').disabled = !hasText;
                document.getElementById('downloadSrtBtn').disabled = !hasText;
            }

            downloadFile(format) {
                const text = document.getElementById('textOutput').value.trim();
                if (!text) {
                    this.showNotification('Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ t·∫£i xu·ªëng.', 'error');
                    return;
                }

                let content, filename, mimeType;
                const timestamp = new Date().toISOString().slice(0,19).replace(/:/g, '-');

                if (format === 'srt') {
                    content = this.generateSRT();
                    filename = `subtitle_${timestamp}.srt`;
                    mimeType = 'text/plain;charset=utf-8';
                } else {
                    content = text;
                    filename = `subtitle_${timestamp}.txt`;
                    mimeType = 'text/plain;charset=utf-8';
                }

                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.showNotification(`üì• ƒê√£ t·∫£i xu·ªëng ${filename}`, 'success');
            }

            generateSRT() {
                let srt = '';
                const duration = parseFloat(document.getElementById('frameInterval').value) || 1;
                
                this.ocrResults
                    .sort((a, b) => a.time - b.time)
                    .forEach((result, index) => {
                        const startTime = result.time;
                        const endTime = startTime + duration;
                        
                        srt += `${index + 1}\n`;
                        srt += `${this.formatSRTTime(startTime)} --> ${this.formatSRTTime(endTime)}\n`;
                        srt += `${result.text}\n\n`;
                    });
                
                return srt;
            }

            formatSRTTime(seconds) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                const ms = Math.floor((seconds % 1) * 1000);
                
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
            }

            formatTime(seconds) {
                const minutes = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${minutes}:${secs.toString().padStart(2, '0')}`;
            }

            showProgress() {
                document.getElementById('progressContainer').style.display = 'block';
            }

            hideProgress() {
                document.getElementById('progressContainer').style.display = 'none';
            }

            updateProgress(percent, text) {
                document.getElementById('progressFill').style.width = `${percent}%`;
                document.getElementById('progressPercent').textContent = `${Math.round(percent)}%`;
                document.getElementById('progressText').textContent = text;
            }

            testFormats() {
                console.log('=== VIDEO FORMAT SUPPORT TEST ===');
                const video = document.createElement('video');
                const formats = [
                    'video/mp4; codecs="avc1.42E01E"',  // MP4 H.264
                    'video/mp4; codecs="mp4v.20.8"',    // MP4 MPEG-4
                    'video/webm; codecs="vp8"',         // WebM VP8
                    'video/webm; codecs="vp9"',         // WebM VP9
                    'video/ogg; codecs="theora"',       // Ogg Theora
                    'video/avi',                        // AVI
                    'video/mov',                        // MOV
                    'video/x-msvideo'                   // AVI alternative
                ];
                
                const results = {};
                formats.forEach(format => {
                    const support = video.canPlayType(format);
                    results[format] = support;
                    console.log(`${format}: ${support || 'not supported'}`);
                });
                
                // Test current browser
                console.log('Browser:', navigator.userAgent);
                console.log('HTMLVideoElement supported:', 'HTMLVideoElement' in window);
                console.log('Media Source Extensions:', 'MediaSource' in window);
                
                this.showNotification('Check Console (F12) ƒë·ªÉ xem k·∫øt qu·∫£ test video format', 'info');
                return results;
            }

            showNotification(message, type = 'info') {
                // Remove existing notifications
                const existing = document.querySelector('.notification');
                if (existing) existing.remove();

                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                document.body.appendChild(notification);

                setTimeout(() => notification.classList.add('show'), 100);
                
                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => notification.remove(), 300);
                }, 5000);
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Initializing Video OCR Extractor...');
            const extractor = new VideoOCRExtractor();
            console.log('Video OCR Extractor initialized');
            
            // Expose to global scope for debugging
            window.videoExtractor = extractor;
        });
    </script>
</body>
</html>
